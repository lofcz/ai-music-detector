using System;
using System.IO;
using System.Linq;
using System.Text.Json;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using CQT;

namespace CQT.Tests;

[TestClass]
public class ResampleTests
{
    /// <summary>
    /// Test Bluestein FFT for arbitrary sizes matches expected.
    /// </summary>
    [TestMethod]
    public void BluesteinFFT_ArbitrarySize_RoundTrip()
    {
        var rng = new Random(42);
            
        foreach (int n in new[] { 7, 11, 13, 17, 100, 127 })
        {
            var original = new Complex[n];
            for (int i = 0; i < n; i++)
            {
                original[i] = new Complex(rng.NextDouble() - 0.5, rng.NextDouble() - 0.5);
            }
                
            var data = (Complex[])original.Clone();
                
            // Forward then inverse should give back original
            FFT.Forward(data);
            FFT.Inverse(data);
                
            double maxDiff = 0;
            for (int i = 0; i < n; i++)
            {
                double diff = Math.Abs(data[i].Real - original[i].Real) +
                              Math.Abs(data[i].Imaginary - original[i].Imaginary);
                maxDiff = Math.Max(maxDiff, diff);
            }
                
            Console.WriteLine($"N={n}: max round-trip diff = {maxDiff:E2}");
            Assert.IsTrue(maxDiff < 1e-10, $"Round-trip failed for N={n}, diff={maxDiff}");
        }
    }

    /// <summary>
    /// Test RFFT/IRFFT for power-of-2 sizes.
    /// </summary>
    [TestMethod]
    public void Rfft_PowerOf2_RoundTrip()
    {
        var rng = new Random(42);
            
        foreach (int n in new[] { 8, 16, 32, 64, 128 })
        {
            var original = new double[n];
            for (int i = 0; i < n; i++)
            {
                original[i] = rng.NextDouble() - 0.5;
            }
                
            var spectrum = FFT.Rfft(original);
            var recovered = FFT.Irfft(spectrum, n);
                
            double maxDiff = 0;
            for (int i = 0; i < n; i++)
            {
                double diff = Math.Abs(recovered[i] - original[i]);
                maxDiff = Math.Max(maxDiff, diff);
            }
                
            Console.WriteLine($"N={n}: max RFFT round-trip diff = {maxDiff:E2}");
            Assert.IsTrue(maxDiff < 1e-10, $"RFFT round-trip failed for N={n}, diff={maxDiff}");
        }
    }

    /// <summary>
    /// Test RFFT/IRFFT for arbitrary sizes (using Bluestein).
    /// </summary>
    [TestMethod]
    public void Rfft_ArbitrarySize_RoundTrip()
    {
        var rng = new Random(42);
            
        foreach (int n in new[] { 10, 50, 100, 200 })
        {
            var original = new double[n];
            for (int i = 0; i < n; i++)
            {
                original[i] = rng.NextDouble() - 0.5;
            }
                
            var spectrum = FFT.Rfft(original);
            var recovered = FFT.Irfft(spectrum, n);
                
            double maxDiff = 0;
            for (int i = 0; i < n; i++)
            {
                double diff = Math.Abs(recovered[i] - original[i]);
                maxDiff = Math.Max(maxDiff, diff);
            }
                
            Console.WriteLine($"N={n}: max RFFT round-trip diff = {maxDiff:E2}");
            Assert.IsTrue(maxDiff < 1e-10, $"RFFT round-trip failed for N={n}, diff={maxDiff}");
        }
    }

    /// <summary>
    /// Test 2x decimation using the scipy.signal.resample algorithm.
    /// </summary>
    [TestMethod]
    public void Decimate2_MatchesScipy()
    {
        // Test vectors generated by Python (seed 42)
        // N=16: input and expected output
        double[] input16 = new double[] {
            0.4967141530112327, -0.13826430117118466, 0.6476885381006925, 1.5230298564080254,
            -0.23415337472333597, -0.23413695694918055, 1.5792128155073915, 0.7674347291529088,
            -0.4694743859349521, 0.5425600435859647, -0.46341769317191653, -0.46572975357025687,
            0.24196227156603412, -1.913280244657798, -1.7249178325130328, -0.5622875292409727
        };
            
        // Expected output from scipy.signal.resample(input16, 8)
        double[] expected16 = new double[] {
            0.01900781068422626, 0.784858335631949, 0.25758567729765915, 0.7697350041478398,
            0.23453076379316178, -0.15064339336395308, -0.6146477550247376, -1.5039562909929977
        };
            
        var output = Decimate2(input16);
            
        Console.WriteLine("N=16 decimation test:");
        Console.WriteLine($"  Expected: [{string.Join(", ", expected16.Select(x => x.ToString("F6")))}]");
        Console.WriteLine($"  Got:      [{string.Join(", ", output.Select(x => x.ToString("F6")))}]");
            
        double maxDiff = 0;
        for (int i = 0; i < output.Length; i++)
        {
            double diff = Math.Abs(output[i] - expected16[i]);
            maxDiff = Math.Max(maxDiff, diff);
        }
            
        Console.WriteLine($"  Max diff: {maxDiff:E2}");
        // Allow for numerical precision differences (Bluestein uses larger FFTs)
        Assert.IsTrue(maxDiff < 1e-6, $"Decimation failed, max diff = {maxDiff}");
    }

    /// <summary>
    /// Replicates the Decimate2 algorithm from LibrosaCQT for testing.
    /// </summary>
    private static double[] Decimate2(double[] input)
    {
        int N = input.Length;
        int M = N / 2;
        double s_fac = 2.0;
        int m = M;
        int m2 = m / 2 + 1;
            
        var X = FFT.Rfft(input);
            
        var X_trunc = new Complex[m2];
        for (int i = 0; i < m2; i++)
        {
            X_trunc[i] = X[i];
        }
            
        if (m % 2 == 0)
        {
            X_trunc[m / 2] = new Complex(
                X_trunc[m / 2].Real * 2,
                X_trunc[m / 2].Imaginary * 2);
        }
            
        for (int i = 0; i < m2; i++)
        {
            X_trunc[i] = new Complex(
                X_trunc[i].Real / s_fac,
                X_trunc[i].Imaginary / s_fac);
        }
            
        return FFT.Irfft(X_trunc, M);
    }
}