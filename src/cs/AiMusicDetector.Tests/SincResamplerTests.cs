using Xunit;
using Xunit.Abstractions;
using System;
using System.IO;
using System.Text.Json;

namespace AiMusicDetector.Tests;

public class SincResamplerTests
{
    private readonly ITestOutputHelper _output;

    public SincResamplerTests(ITestOutputHelper output)
    {
        _output = output;
    }

    [Fact]
    public void Resample_MatchesTorchaudio_44100_To_16000()
    {
        // Load test data generated by Python
        var testDataPath = Path.Combine(
            Path.GetDirectoryName(typeof(SincResamplerTests).Assembly.Location)!,
            "..", "..", "..", "..", "..", "..", "src", "python", "resample_test_data.json");
        
        if (!File.Exists(testDataPath))
        {
            // Try alternative path
            testDataPath = @"C:\Users\lordo\Documents\GitHub\ai-music-detector\src\python\resample_test_data.json";
        }

        if (!File.Exists(testDataPath))
        {
            _output.WriteLine($"Test data not found at: {testDataPath}");
            _output.WriteLine("Run _test_resample_match.py first to generate test data");
            return;
        }

        var json = File.ReadAllText(testDataPath);
        var testData = JsonSerializer.Deserialize<ResampleTestData>(json)!;

        _output.WriteLine($"Testing resample {testData.orig_freq} -> {testData.new_freq}");
        _output.WriteLine($"Input samples: {testData.input.Length}");
        _output.WriteLine($"Expected output samples: {testData.expected_output.Length}");

        // Convert input to float[]
        var input = new float[testData.input.Length];
        for (int i = 0; i < testData.input.Length; i++)
            input[i] = (float)testData.input[i];

        // Resample using our implementation
        var output = SincResampler.Resample(
            input, 
            testData.orig_freq, 
            testData.new_freq, 
            testData.lowpass_filter_width, 
            testData.rolloff);

        _output.WriteLine($"\nActual output samples: {output.Length}");
        
        // Calculate expected output length for our input length
        int expectedLen = (int)Math.Ceiling((double)testData.new_freq * testData.input.Length / testData.orig_freq);
        _output.WriteLine($"Expected output length for {testData.input.Length} inputs: {expectedLen}");
        
        // Compare only the samples we have (the first N samples should match)
        int compareLen = Math.Min(output.Length, testData.expected_output.Length);
        _output.WriteLine($"Comparing first {compareLen} samples");
        
        _output.WriteLine($"\nFirst 20 samples comparison:");
        _output.WriteLine($"{"Index",-6} {"Expected",-18} {"Actual",-18} {"Diff",-12}");
        _output.WriteLine(new string('-', 60));

        double maxDiff = 0;
        double sumDiff = 0;
        
        for (int i = 0; i < Math.Min(20, compareLen); i++)
        {
            var expected = testData.expected_output[i];
            var actual = (double)output[i];
            var diff = Math.Abs(expected - actual);
            _output.WriteLine($"{i,-6} {expected,-18:F10} {actual,-18:F10} {diff,-12:E3}");
        }

        for (int i = 0; i < compareLen; i++)
        {
            var diff = Math.Abs(testData.expected_output[i] - output[i]);
            maxDiff = Math.Max(maxDiff, diff);
            sumDiff += diff;
        }

        _output.WriteLine($"\nMax diff: {maxDiff:E6}");
        _output.WriteLine($"Mean diff: {sumDiff / compareLen:E6}");

        // Assert that we're within tolerance (1e-5 for float precision)
        Assert.True(maxDiff < 1e-5, $"Max diff {maxDiff} exceeds tolerance 1e-5");
    }

    private class ResampleTestData
    {
        public int orig_freq { get; set; }
        public int new_freq { get; set; }
        public int lowpass_filter_width { get; set; }
        public double rolloff { get; set; }
        public double[] input { get; set; } = Array.Empty<double>();
        public double[] expected_output { get; set; } = Array.Empty<double>();
    }
}
